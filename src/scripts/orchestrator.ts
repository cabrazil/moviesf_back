import { PrismaClient } from '@prisma/client';
import { spawn } from 'child_process';
import path from 'path';
import { writeFileSync } from 'fs';
import { selectOptimalAIProvider, createAIProvider, getDefaultConfig, AIProvider } from '../utils/aiProvider';

const prisma = new PrismaClient();

interface MovieToProcess {
  title: string;
  year: number;
  journeyOptionFlowId: number;
  analysisLens: number;
  journeyValidation: number;
  aiProvider?: 'openai' | 'gemini' | 'auto';
}

interface ProcessingResult {
  success: boolean;
  movie?: { title: string; year: number; id: string };
  error?: string;
}

class MovieCurationOrchestrator {
  private readonly scriptsPath = path.join(__dirname);
  private readonly insertFile = path.join(__dirname, '../../inserts.sql');

  async processMovieList(movies: MovieToProcess[], approveNewSubSentiments: boolean): Promise<ProcessingResult[]> {
    console.log(`\nüé¨ === ORQUESTRADOR DE CURADORIA DE FILMES ===`);
    console.log(`üìã Processando ${movies.length} filmes...`);
    
    const results: ProcessingResult[] = [];
    
    for (const movie of movies) {
      console.log(`\nüîÑ Processando: ${movie.title} (${movie.year})`);
      const result = await this.processSingleMovie(movie, approveNewSubSentiments);
      results.push(result);
    }
    
    return results;
  }

  private async processSingleMovie(movie: MovieToProcess, approveNewSubSentiments: boolean): Promise<ProcessingResult> {
    try {
      // Etapa 0: Limpar arquivo de inserts
      writeFileSync(this.insertFile, '');
      console.log(`üßπ Arquivo inserts.sql limpo.`);

      // Etapa 1: Adicionar filme
      console.log(`üì• Etapa 1: Adicionando filme ao banco...`);
      const addResult = await this.runScript('populateMovies.ts', [`--title=${movie.title}`, `--year=${movie.year.toString()}`]);
      
      if (!addResult.success) {
        return { success: false, error: `Falha ao adicionar filme: ${addResult.error}` };
      }

      // Capturar o TMDB ID do output
      const tmdbIdMatch = addResult.output.match(/TMDB_ID_FOUND: (\d+)/);
      if (!tmdbIdMatch) {
        return { success: false, error: 'TMDB ID n√£o encontrado no output do populateMovies.ts' };
      }
      const tmdbId = parseInt(tmdbIdMatch[1]);
      console.log(`üéØ TMDB ID capturado: ${tmdbId}`);

      // Determinar o AI Provider automaticamente se necess√°rio
      let finalAiProvider = movie.aiProvider;
      if (movie.aiProvider === 'auto') {
        // Buscar informa√ß√µes do filme para decis√£o autom√°tica
        const movieData = await prisma.movie.findUnique({ 
          where: { tmdbId: tmdbId }
        });

        if (movieData) {
          const context = {
            genres: movieData.genres || [],
            keywords: movieData.keywords || [],
            analysisLens: movie.analysisLens,
            isComplexDrama: movieData.genres?.some((g: string) => g.toLowerCase().includes('drama')) || false
          };

          finalAiProvider = selectOptimalAIProvider(context);
          console.log(`ü§ñ AI Provider selecionado automaticamente: ${finalAiProvider.toUpperCase()}`);
          console.log(`üìä Baseado em: G√™neros [${context.genres?.join(', ')}], Lente ${movie.analysisLens}`);
        } else {
          finalAiProvider = 'gemini'; // Fallback para economia
          console.log(`‚ö†Ô∏è Dados do filme n√£o encontrados, usando Gemini como fallback`);
        }
      }

      // Etapa 2: Analisar sentimentos
      console.log(`üß† Etapa 2: Analisando sentimentos...`);
      const analysisArgs = [
        tmdbId.toString(), // Usar tmdbId 
        movie.journeyOptionFlowId.toString(),
        movie.analysisLens.toString()
      ];
      
      // Adicionar provedor de IA final
      if (finalAiProvider) {
        analysisArgs.push(`--ai-provider=${finalAiProvider}`);
      }
      
      const analysisResult = await this.runScript('analyzeMovieSentiments.ts', analysisArgs);
      
      if (!analysisResult.success) {
        return { success: false, error: `Falha na an√°lise: ${analysisResult.error}` };
      }

      // Etapa 2.5: Verifica√ß√£o de Aprova√ß√£o do Curador
      const approvalLine = analysisResult.output.split('\n').find((line: string) => line.startsWith('CURATOR_APPROVAL_NEEDED'));
      if (approvalLine) {
        if (!approveNewSubSentiments) {
            const jsonString = approvalLine.replace('CURATOR_APPROVAL_NEEDED: ', '');
            const suggestions = JSON.parse(jsonString);

            console.log('\n--------------------------------------------------');
            console.log('‚ö†Ô∏è APROVA√á√ÉO DO CURADOR NECESS√ÅRIA ‚ö†Ô∏è');
            console.log('A IA sugeriu a cria√ß√£o dos seguintes SubSentimentos:');
            suggestions.forEach((sug: { name: string; explanation: string }) => {
                console.log(`\n  - Nome: "${sug.name}"`);
                console.log(`    Explica√ß√£o: ${sug.explanation}`);
            });
            console.log('\nPara aprovar, execute o comando novamente adicionando a flag: --approve-new-subsentiments');
            console.log('--------------------------------------------------');
            return { success: false, error: 'Aprova√ß√£o necess√°ria para novo subsentimento.' };
        }
        console.log('‚úÖ Novos subsentimentos aprovados via flag. Continuando processo...');
      }

      // Etapa 3: Executar INSERTs
      console.log(`üíæ Etapa 3: Executando INSERTs...`);
      const insertResult = await this.runScript('executeSqlFromFile.ts', [this.insertFile]);
      if (!insertResult.success) {
        console.log(`‚ö†Ô∏è Aviso: Falha ao executar INSERTs: ${insertResult.error}`);
      }

      // Etapa 4: Descobrir e curar
      console.log(`üéØ Etapa 4: Descobrindo e curando...`);
      const curateArgs = [
        tmdbId.toString(), // Usar tmdbId
        movie.journeyValidation.toString(),
        movie.journeyOptionFlowId.toString(),
        'PROCESS'
      ];
      
      // Adicionar provedor de IA final
      if (finalAiProvider) {
        curateArgs.push(`--ai-provider=${finalAiProvider}`);
      }
      
      const curateResult = await this.runScript('discoverAndCurateAutomated.ts', curateArgs);
      
      if (!curateResult.success) {
        return { success: false, error: `Falha na curadoria: ${curateResult.error}` };
      }

      // Etapa 5: Gerar landingPageHook
      console.log(`üé£ Etapa 5: Gerando landingPageHook...`);
      const hookResult = await this.generateLandingPageHook(tmdbId, finalAiProvider);
      if (!hookResult.success) {
        console.log(`‚ö†Ô∏è Aviso: Falha ao gerar landingPageHook: ${hookResult.error}`);
      } else {
        console.log(`üé£ LandingPageHook gerado: "${hookResult.hook}"`);
      }

      // Etapa 6: Gerar contentWarnings
      console.log(`‚ö†Ô∏è Etapa 6: Gerando contentWarnings...`);
      const warningsResult = await this.generateContentWarnings(tmdbId, finalAiProvider);
      if (!warningsResult.success) {
        console.log(`‚ö†Ô∏è Aviso: Falha ao gerar contentWarnings: ${warningsResult.error}`);
      } else {
        console.log(`‚ö†Ô∏è ContentWarning gerado: "${warningsResult.warning}"`);
      }

      const createdMovie = await prisma.movie.findFirst({ 
        where: { title: movie.title, year: movie.year },
        include: { 
          movieSuggestionFlows: {
            where: { journeyOptionFlowId: movie.journeyOptionFlowId },
            orderBy: { updatedAt: 'desc' },
            take: 1
          }
        }
      });
      if (!createdMovie) {
        return { success: false, error: 'Filme n√£o encontrado no banco de dados ap√≥s o processo.' };
      }

      console.log(`‚úÖ Filme processado com sucesso: ${movie.title} (${movie.year})`);
      // Log da reflex√£o sobre o filme (reason) da sugest√£o espec√≠fica atualizada
      if (createdMovie.movieSuggestionFlows.length > 0) {
        const updatedSuggestion = createdMovie.movieSuggestionFlows[0];
        console.log(`üí≠ Reflex√£o sobre o filme: ${updatedSuggestion.reason}`);
      }
      return { 
        success: true, 
        movie: { 
          title: createdMovie.title, 
          year: createdMovie.year || 0, 
          id: createdMovie.id 
        } 
      };
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`‚ùå Erro ao processar ${movie.title}:`, errorMessage);
      return { success: false, error: `Erro inesperado: ${errorMessage}` };
    }
  }

  private async generateLandingPageHook(tmdbId: number, aiProvider?: string): Promise<{ success: boolean; hook?: string; error?: string }> {
    try {
      // Buscar dados do filme com sentimentos e explica√ß√µes
      const movie = await prisma.movie.findUnique({
        where: { tmdbId: tmdbId },
        select: {
          title: true,
          year: true,
          genres: true,
          keywords: true,
          description: true,
          movieSentiments: {
            select: {
              relevance: true,
              explanation: true,
              subSentiment: {
                select: {
                  name: true
                }
              }
            },
            orderBy: {
              relevance: 'desc'
            },
            take: 3 // Pegar os 3 mais relevantes
          }
        }
      });

      if (!movie) {
        return { success: false, error: 'Filme n√£o encontrado no banco de dados' };
      }

      // Construir o prompt com explica√ß√µes dos sentimentos
      let sentimentContext = '';
      if (movie.movieSentiments && movie.movieSentiments.length > 0) {
        sentimentContext = '\n\nAn√°lise emocional do filme:\n';
        movie.movieSentiments.forEach((sentiment, index) => {
          sentimentContext += `${index + 1}. ${sentiment.subSentiment.name} (Relev√¢ncia: ${sentiment.relevance}): ${sentiment.explanation}\n`;
        });
      }

      const prompt = 'Para o filme \'' + movie.title + '\' (' + movie.year + '), com g√™neros: ' + (movie.genres?.join(', ') || 'N/A') + ', palavras-chave principais: ' + (movie.keywords?.slice(0, 10).join(', ') || 'N/A') + ', e sinopse: ' + (movie.description || 'N/A') + '.' + sentimentContext + '\n\nAnalise os sentimentos emocionais do filme e crie uma estrutura JSON com os subsentimentos mais relevantes, seguida de uma frase de gancho cativante.\n\nFORMATO DE RESPOSTA OBRIGAT√ìRIO (SEM BLOCO DE C√ìDIGO):\n{\n  "suggestedSubSentiments": [\n    {\n      "name": "Nome do SubSentimento",\n      "relevance": 0.95,\n      "explanation": "Explica√ß√£o detalhada de como este subsentimento se manifesta no filme",\n      "isNew": false\n    }\n  ]\n}\n\nPrepare-se para [emo√ß√£o/experi√™ncia]: ' + movie.title + ' [descri√ß√£o cativante do apelo principal].\n\nIMPORTANTE: Responda SEM usar blocos de c√≥digo. Use apenas o JSON puro seguido do texto do hook. Use as an√°lises emocionais fornecidas para identificar os 3 subsentimentos mais relevantes e criar um gancho impactante.';

      // Configurar IA Provider
      const provider = aiProvider as AIProvider || 'openai';
      const config = getDefaultConfig(provider);
      const ai = createAIProvider(config);

      // Gerar texto com IA
      const systemPrompt = "Voc√™ √© um especialista em marketing cinematogr√°fico que cria ganchos cativantes para landing pages de filmes.";
      const response = await ai.generateResponse(systemPrompt, prompt, {
        maxTokens: 800,
        temperature: 0.7
      });

      if (!response.success) {
        return { success: false, error: `Falha na gera√ß√£o: ${response.error}` };
      }

      // Extrair o texto gerado
      const generatedText = response.content.trim();
      
      // Validar se o texto foi gerado
      if (!generatedText || generatedText.length < 10) {
        return { success: false, error: 'Texto gerado muito curto ou vazio' };
      }

      // Salvar a estrutura JSON completa (com suggestedSubSentiments + texto do hook)
      const completeStructure = generatedText.trim();

      // Atualizar o filme no banco de dados
      await prisma.movie.update({
        where: { tmdbId: tmdbId },
        data: { landingPageHook: completeStructure }
      });

      return { success: true, hook: completeStructure };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: `Erro ao gerar landingPageHook: ${errorMessage}` };
    }
  }

  private async generateContentWarnings(tmdbId: number, aiProvider?: string): Promise<{ success: boolean; warning?: string; error?: string }> {
    try {
      // Buscar dados do filme com sentimentos e explica√ß√µes
      const movie = await prisma.movie.findUnique({
        where: { tmdbId: tmdbId },
        select: {
          title: true,
          year: true,
          genres: true,
          keywords: true,
          description: true,
          movieSentiments: {
            select: {
              relevance: true,
              explanation: true,
              subSentiment: {
                select: {
                  name: true
                }
              }
            },
            orderBy: {
              relevance: 'desc'
            },
            take: 1 // Pegar apenas o mais relevante para contexto
          }
        }
      });

      if (!movie) {
        return { success: false, error: 'Filme n√£o encontrado no banco de dados' };
      }

      // Construir o contexto emocional se dispon√≠vel
      let sentimentContext = '';
      if (movie.movieSentiments && movie.movieSentiments.length > 0) {
        const topSentiment = movie.movieSentiments[0];
        sentimentContext = `\n\nContexto emocional principal: ${topSentiment.subSentiment.name} (Relev√¢ncia: ${topSentiment.relevance}): ${topSentiment.explanation}`;
      }

      const prompt = `Com base no filme '${movie.title}' (${movie.year}), g√™neros: ${movie.genres?.join(', ') || 'N/A'}, palavras-chave principais: ${movie.keywords?.slice(0, 15).join(', ') || 'N/A'}, e sinopse: ${movie.description || 'N/A'}.${sentimentContext}

Sintetize os principais alertas de tonalidade ou conte√∫do para o espectador em UMA √öNICA FRASE concisa e objetiva, come√ßando com 'Aten√ß√£o:'. **N√£o inclua numera√ß√£o, marcadores de lista, ou quebras de linha. O resultado deve ser apenas a frase sintetizada.**

Considere as seguintes categorias de alerta para identificar:
- Viol√™ncia (f√≠sica, psicol√≥gica, expl√≠cita)
- Temas adultos (nudez, sexualidade expl√≠cita, uso de drogas, linguagem forte/ofensiva)
- Intensidade emocional (cenas que podem ser perturbadoras, muito tristes ou angustiantes)
- Temas de preconceito/discrimina√ß√£o (racial, de g√™nero, por orienta√ß√£o sexual, por identidade de g√™nero, por defici√™ncia, etc.)
- Representa√ß√£o LGBTQIA+ (se a representa√ß√£o em si ou os desafios dos personagens forem um ponto de aten√ß√£o para o conte√∫do)
- Humor √°cido/controverso
- Outros elementos que possam causar impacto (flashbacks intensos, barulhos altos, edi√ß√£o ca√≥tica, temas de abuso/ass√©dio)

Exemplo de sa√≠da esperada (sem numera√ß√£o ou quebras de linha):
"Aten√ß√£o: cont√©m cenas intensas de viol√™ncia, temas adultos e pode ser emocionalmente perturbador."
"Aten√ß√£o: explora preconceito racial e cont√©m linguagem forte."
"Aten√ß√£o: aborda temas LGBTQIA+ com foco em desafios sociais."
"Aten√ß√£o: possui humor √°cido e situa√ß√µes controversas."

Se n√£o houver alertas significativos, responda apenas com:
"Aten√ß√£o: nenhum alerta de conte√∫do significativo."`;

      // Configurar IA Provider
      const provider = aiProvider as AIProvider || 'openai';
      const config = getDefaultConfig(provider);
      const ai = createAIProvider(config);

      // Gerar texto com IA
      const systemPrompt = "Voc√™ √© um especialista em an√°lise de conte√∫do cinematogr√°fico que identifica alertas importantes para espectadores.";
      const response = await ai.generateResponse(systemPrompt, prompt, {
        maxTokens: 300,
        temperature: 0.3
      });

      if (!response.success) {
        return { success: false, error: `Falha na gera√ß√£o: ${response.error}` };
      }

      // Extrair o texto gerado
      const generatedText = response.content.trim();
      
      // Validar se o texto foi gerado
      if (!generatedText || generatedText.length < 10) {
        return { success: false, error: 'Texto gerado muito curto ou vazio' };
      }

      // Remover quaisquer blocos de c√≥digo (ex.: ```json ... ```)
      const withoutCodeBlocks = generatedText.replace(/```[\s\S]*?```/g, '').trim();

      // Tentar extrair explicitamente a √∫ltima linha que contenha "Aten√ß√£o:"
      const attentionLines = withoutCodeBlocks
        .split('\n')
        .map(l => l.trim())
        .filter(l => /(^|\s)Aten√ß√£o:/i.test(l));

      let warning = '';
      if (attentionLines.length > 0) {
        // Pegar a √∫ltima ocorr√™ncia
        warning = attentionLines[attentionLines.length - 1];
      } else {
        // Se n√£o houver linha espec√≠fica, usar o texto inteiro sem blocos de c√≥digo
        warning = withoutCodeBlocks;
      }

      // Normalizar: manter somente a frase come√ßando em "Aten√ß√£o:" at√© o final
      const match = warning.match(/Aten√ß√£o:\s*(.*)$/i);
      if (match && match[1]) {
        warning = `Aten√ß√£o: ${match[1].trim()}`;
      }

      // Remover aspas iniciais/finais, se existirem
      warning = warning.replace(/^\s*["']|["']\s*$/g, '').trim();

      // Garantias finais
      if (!warning || warning.length < 10) {
        if (generatedText.toLowerCase().includes('nenhum alerta') || generatedText.toLowerCase().includes('sem alertas')) {
          warning = 'Aten√ß√£o: nenhum alerta de conte√∫do significativo.';
        } else {
          warning = 'Aten√ß√£o: conte√∫do pode conter temas adultos.';
        }
      }

      // Atualizar o filme no banco de dados
      await prisma.movie.update({
        where: { tmdbId: tmdbId },
        data: { contentWarnings: warning }
      });

      return { success: true, warning };

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: `Erro ao gerar contentWarnings: ${errorMessage}` };
    }
  }

  private async runScript(scriptName: string, args: string[]): Promise<{ success: boolean; output: string; error?: string }> {
    return new Promise((resolve) => {
      const scriptPath = path.join(this.scriptsPath, scriptName);
      const child = spawn('npx', ['ts-node', scriptPath, ...args], {
        stdio: 'pipe',
        cwd: path.dirname(this.scriptsPath)
      });

      let output = '';
      let errorOutput = '';

      child.stdout.on('data', (data) => {
        const chunk = data.toString();
        if (!chunk.startsWith('CURATOR_APPROVAL_NEEDED')) {
            process.stdout.write(chunk);
        }
        output += chunk;
      });

      child.stderr.on('data', (data) => {
        process.stderr.write(data);
        errorOutput += data.toString();
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, output });
        } else {
          resolve({ success: false, output, error: errorOutput || `Script ${scriptName} falhou com c√≥digo ${code}` });
        }
      });
    });
  }
}

function parseNamedArgs(args: string[]): Partial<MovieToProcess> {
  const parsed: Partial<MovieToProcess> = {};
  for (const arg of args) {
    if (arg.startsWith('--title=')) parsed.title = arg.split('=')[1];
    else if (arg.startsWith('--year=')) parsed.year = parseInt(arg.split('=')[1]);
    else if (arg.startsWith('--journeyOptionFlowId=')) parsed.journeyOptionFlowId = parseInt(arg.split('=')[1]);
    else if (arg.startsWith('--analysisLens=')) parsed.analysisLens = parseInt(arg.split('=')[1]);
    else if (arg.startsWith('--journeyValidation=')) parsed.journeyValidation = parseInt(arg.split('=')[1]);
    else if (arg.startsWith('--ai-provider=')) parsed.aiProvider = arg.split('=')[1] as 'openai' | 'gemini' | 'auto';
  }
  return parsed;
}

async function main() {
  const orchestrator = new MovieCurationOrchestrator();
  try {
    const args = process.argv.slice(2);
    const approveNewSubSentiments = args.includes('--approve-new-subsentiments');
    const filteredArgs = args.filter(arg => arg !== '--approve-new-subsentiments');

    if (filteredArgs.length === 0 || filteredArgs.includes('--help')) {
      console.log(`üé¨ === ORQUESTRADOR DE CURADORIA DE FILMES ===`);
      console.log(`\nUso: npx ts-node orchestrator.ts --title="T√≠tulo" --year=2023 --journeyOptionFlowId=81 --analysisLens=14 --journeyValidation=15`);
      console.log(`\nFlags opcionais:`);
      console.log(`   --approve-new-subsentiments: Aprova automaticamente a cria√ß√£o de novos subsentimentos sugeridos pela IA.`);
      console.log(`   --ai-provider=openai|gemini|auto: Escolhe o provedor de IA (padr√£o: openai, auto=sele√ß√£o autom√°tica baseada no filme).`);
      return;
    }

    const parsed = parseNamedArgs(filteredArgs);
    if (!parsed.title || !parsed.year || !parsed.journeyOptionFlowId || !parsed.analysisLens || !parsed.journeyValidation) {
      console.log('‚ùå Erro: Todos os par√¢metros s√£o obrigat√≥rios (title, year, journeyOptionFlowId, analysisLens, journeyValidation). Use --help para mais informa√ß√µes.');
      return;
    }

    const movie: MovieToProcess = parsed as MovieToProcess;
    await orchestrator.processMovieList([movie], approveNewSubSentiments);

  } catch (error) {
    console.error('‚ùå Erro fatal:', error);
  } finally {
    await prisma.$disconnect();
  }
}

if (require.main === module) {
  main();
}

export { MovieCurationOrchestrator };
