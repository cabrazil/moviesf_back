generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  directUrl    = env("DIRECT_URL")
  relationMode = "prisma"
}


model Movie {
  id                   String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title                String                @unique @db.VarChar(255)
  slug                  String?               @unique @db.VarChar(255)  // NOVO CAMPO
  year                 Int?
  director             String?               @db.VarChar(255)
  genres               String[]
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  description          String?
  thumbnail            String?
  original_title       String?
  vote_average         Decimal?              @db.Decimal(3, 1)
  vote_count           Int?
  certification        String?               @db.VarChar(255)
  adult                Boolean?              @default(false)
  keywords             String[]
  genreIds             Int[]
  runtime              Int?
  tmdbId               Int?                  @unique
  imdbRating           Decimal? @db.Decimal(3, 1)
  rottenTomatoesRating Int?
  metacriticRating     Int?
  landingPageHook      String?
  contentWarnings      String?
  targetAudienceForLP  String?
  awardsSummary        String?
  movieSentiments      MovieSentiment[]
  movieSuggestionFlows MovieSuggestionFlow[]
  // NOVA RELAÇÃO: Streaming platforms (mantendo campo antigo para migração segura)
  platforms            MovieStreamingPlatform[]
  // NOVA RELAÇÃO: Elenco do filme
  cast                 MovieCast[]
  // NOVA RELAÇÃO: Trailers do filme
  trailers             MovieTrailer[]
  
  // NOVAS RELAÇÕES: Premiações detalhadas
  awardNominations     MovieAwardNomination[]
  awardWins            MovieAwardWin[]
  personAwardNominations PersonAwardNomination[] @relation("PersonAwardForMovie")
  personAwardWins      PersonAwardWin[] @relation("PersonAwardForMovieWin")
  
  // NOVAS RELAÇÕES: Críticas do filme
  quotes               Quote[]

  @@index([title])
  @@index([year]) // Consultas por ano são frequentes
  @@index([tmdbId]) // Integração com TMDB
  @@index([createdAt]) // Ordenação e filtros temporais
}

model Genre {
  id   Int    @id @default(autoincrement())
  name String @unique
}

model MainSentiment {
  id                  Int                  @id @default(autoincrement())
  name                String               @unique @db.VarChar(255)
  description         String?
  keywords            String[]             @default([])
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  shortDescription    String?
  journeyFlow         JourneyFlow?
  movieSentiment      MovieSentiment[]
  subSentiments       SubSentiment[]
  emotionalIntentions EmotionalIntention[]
}

model SubSentiment {
  id              Int              @id @default(autoincrement())
  name            String           @db.VarChar(255)
  description     String?
  keywords        String[]         @default([])
  mainSentimentId Int
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  movieSentiment  MovieSentiment[]
  mainSentiment   MainSentiment    @relation(fields: [mainSentimentId], references: [id])

  @@index([mainSentimentId])
}

model MovieSentiment {
  movieId         String        @db.Uuid
  mainSentimentId Int
  subSentimentId  Int
  relevance       Decimal?      @db.Decimal(5, 3)
  explanation     String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  mainSentiment   MainSentiment @relation(fields: [mainSentimentId], references: [id])
  movie           Movie         @relation(fields: [movieId], references: [id])
  subSentiment    SubSentiment  @relation(fields: [subSentimentId], references: [id])

  @@id([movieId, mainSentimentId, subSentimentId])
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([mainSentimentId]) // ESSENCIAL: relacionamento com MainSentiment
  @@index([subSentimentId]) // ESSENCIAL: relacionamento com SubSentiment
}

model JourneyFlow {
  id              Int               @id @default(autoincrement())
  mainSentimentId Int               @unique
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  mainSentiment   MainSentiment     @relation(fields: [mainSentimentId], references: [id])
  steps           JourneyStepFlow[]
}

model JourneyStepFlow {
  id                             Int                             @id @default(autoincrement())
  journeyFlowId                  Int
  stepId                         String                          @db.VarChar(255)
  order                          Int
  question                       String
  createdAt                      DateTime                        @default(now())
  updatedAt                      DateTime                        @updatedAt
  options                        JourneyOptionFlow[]
  journeyFlow                    JourneyFlow                     @relation(fields: [journeyFlowId], references: [id])
  emotionalIntentionJourneySteps EmotionalIntentionJourneyStep[]

  @@index([journeyFlowId]) // ESSENCIAL: relacionamento
  @@index([order]) // ESSENCIAL: ordenação dos passos
}

model JourneyOptionFlow {
  id                Int                   @id @default(autoincrement())
  journeyStepFlowId Int
  optionId          String                @db.VarChar(255)
  text              String
  nextStepId        String?               @db.VarChar(255)
  isEndState        Boolean               @default(false)
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  journeyStepFlow   JourneyStepFlow       @relation(fields: [journeyStepFlowId], references: [id])
  movieSuggestions  MovieSuggestionFlow[]

  @@index([journeyStepFlowId]) // ESSENCIAL: relacionamento
  @@index([nextStepId]) // ESSENCIAL: navegação entre opções
}

model MovieSuggestionFlow {
  id                  Int               @id @default(autoincrement())
  journeyOptionFlowId Int
  movieId             String            @db.Uuid
  reason              String
  relevance           Int               @default(1)
  relevanceScore      Decimal?          @db.Decimal(5, 3) // Score de relevância baseado na soma dos subsentimentos
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  journeyOptionFlow   JourneyOptionFlow @relation(fields: [journeyOptionFlowId], references: [id])
  movie               Movie             @relation(fields: [movieId], references: [id])

  @@index([journeyOptionFlowId]) // ESSENCIAL: relacionamento
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([relevanceScore]) // ESSENCIAL: ordenação por relevância
}

model GenreSubSentiment {
  id             Int      @id @default(autoincrement())
  genreId        Int
  subSentimentId Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([genreId, subSentimentId])
}

model JourneyOptionFlowSubSentiment {
  id                  Int      @id @default(autoincrement())
  journeyOptionFlowId Int
  subSentimentId      Int
  weight              Decimal  @default(1.0) @db.Decimal(3, 2)
  createdAt           DateTime @default(now())
  updatedAt           DateTime

  @@unique([journeyOptionFlowId, subSentimentId])
  @@index([journeyOptionFlowId])
  @@index([subSentimentId])
}

model EmotionalIntention {
  id                             Int                             @id @default(autoincrement())
  mainSentimentId                Int
  intentionType                  IntentionType
  description                    String
  preferredGenres                String[]                        @default([])
  avoidGenres                    String[]                        @default([])
  emotionalTone                  String                          @default("similar")
  subSentimentWeights            Json
  createdAt                      DateTime                        @default(now())
  updatedAt                      DateTime                        @updatedAt
  mainSentiment                  MainSentiment                   @relation(fields: [mainSentimentId], references: [id])
  emotionalIntentionJourneySteps EmotionalIntentionJourneyStep[]

  @@unique([mainSentimentId, intentionType])
  @@index([mainSentimentId]) // ESSENCIAL: relacionamento
  @@index([intentionType]) // ESSENCIAL: filtros por tipo
}

model EmotionalIntentionJourneyStep {
  id                   Int                @id @default(autoincrement())
  emotionalIntentionId Int
  journeyStepFlowId    Int
  priority             Int                @default(1)
  isRequired           Boolean            @default(false)
  customQuestion       String?
  contextualHint       String?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  emotionalIntention   EmotionalIntention @relation(fields: [emotionalIntentionId], references: [id])
  journeyStepFlow      JourneyStepFlow    @relation(fields: [journeyStepFlowId], references: [id])

  @@unique([emotionalIntentionId, journeyStepFlowId])
  @@index([emotionalIntentionId]) // ESSENCIAL: relacionamento
  @@index([journeyStepFlowId]) // ESSENCIAL: relacionamento
  @@index([priority]) // ESSENCIAL: ordenação por prioridade
}

enum IntentionType {
  PROCESS
  TRANSFORM
  MAINTAIN
  EXPLORE
}

// ===============================================
// NOVAS ESTRUTURAS PARA STREAMING PLATFORMS
// ===============================================

// Enum para os tipos de serviço de acesso a um filme em uma plataforma
enum AccessType {
  INCLUDED_WITH_SUBSCRIPTION // Incluído na assinatura (ex: Netflix, Prime Video com Prime)
  RENTAL                    // Apenas para aluguel
  PURCHASE                  // Apenas para compra
  FREE_WITH_ADS             // Gratuito com anúncios (ex: YouTube, Pluto TV)
  HYBRID_OR_UNKNOWN         // Quando não sabemos o tipo exato ou plataforma oferece múltiplos tipos
  OTHER                     // Outros modelos de acesso
}

// Enum para a categoria principal da plataforma (para filtros de alto nível na UI)
enum PlatformCategory {
  SUBSCRIPTION_PRIMARY      // Plataformas primariamente de assinatura (Netflix, HBO Max)
  RENTAL_PURCHASE_PRIMARY   // Plataformas primariamente de aluguel/compra (Google Play Filmes, Apple TV Loja)
  FREE_PRIMARY              // Plataformas primariamente gratuitas (Pluto TV, YouTube Free)
  HYBRID                    // Plataformas que oferecem múltiplos modelos como principal (Amazon Prime Video)
}

// Nova Model para Plataformas de Streaming (a plataforma em si)
model StreamingPlatform {
  id        Int              @id @default(autoincrement())
  name      String           @unique @db.VarChar(255) // Ex: "Netflix", "Amazon Prime Video", "Apple TV (Loja)", "Apple TV+"
  category  PlatformCategory // Categoria principal da plataforma (para filtros de alto nível)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @default(now())
  baseUrl   String?          @db.VarChar(500) // URL base da plataforma para redirecionamento
  hasFreeTrial Boolean       @default(false) // Se a plataforma oferece teste grátis
  freeTrialDuration String?  @db.VarChar(100) // Duração do teste grátis (ex: '7 dias', '30 dias', '1 mês')
  logoPath   String?          @db.VarChar(500) // URL da imagem da plataforma (local ou externa)
  
  
  // Relação muitos-para-muitos com filmes, através da tabela de junção
  movies    MovieStreamingPlatform[]

  // Tabela pequena, apenas índices essenciais
  @@index([category]) // ESSENCIAL: filtros por categoria
}

// Tabela de Junção para a relação muitos-para-muitos entre Movie e StreamingPlatform
// Crucial: Agora inclui o tipo de acesso para aquele filme específico naquela plataforma
model MovieStreamingPlatform {
  movieId             String           @db.Uuid
  streamingPlatformId Int
  accessType          AccessType       // O TIPO DE ACESSO para ESTE filme NESTA plataforma
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @default(now())
  movie               Movie            @relation(fields: [movieId], references: [id])
  streamingPlatform   StreamingPlatform @relation(fields: [streamingPlatformId], references: [id])

  // Chave composta para permitir que o mesmo filme esteja na mesma plataforma com diferentes tipos de acesso
  @@id([movieId, streamingPlatformId, accessType])
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([streamingPlatformId]) // ESSENCIAL: relacionamento com StreamingPlatform
}

// ===============================================
// ESTRUTURAS PARA ELENCO (CAST)
// ===============================================

// Tabela para armazenar informações dos atores
model Actor {
  id           String      @id @default(uuid()) @db.Uuid // ID interno do seu sistema
  tmdbId       Int         @unique // ID do ator no TMDB (para referência externa)
  name         String      // Nome completo do ator
  profilePath  String?     // Caminho para a imagem do perfil do ator no TMDB (ex: /path/to/image.jpg)
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @default(now())

  // Relação com a tabela MovieCast (para os filmes em que atuou)
  movies       MovieCast[]
  
  // NOVAS RELAÇÕES: Premiações de pessoas
  awardNominations PersonAwardNomination[]
  awardWins        PersonAwardWin[]

  @@map("Actor") // Nome da tabela no banco
  @@index([tmdbId]) // ESSENCIAL: integração com TMDB
  @@index([name]) // ESSENCIAL: busca por nome de ator
}

// Tabela de associação entre Filmes e Atores (Elenco)
model MovieCast {
  id           String    @id @default(uuid()) @db.Uuid // ID interno
  movieId      String    @db.Uuid // ID do filme
  actorId      String    @db.Uuid // ID do ator
  characterName String?   // Nome do personagem que o ator interpretou
  order        Int       // Ordem de aparição no elenco (para pegar os principais)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now())

  // Relações
  movie        Movie     @relation(fields: [movieId], references: [id])
  actor        Actor     @relation(fields: [actorId], references: [id])

  @@unique([movieId, actorId]) // Um ator só atua uma vez em um filme (para um mesmo personagem)
  @@map("MovieCast") // Nome da tabela no banco
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([actorId]) // ESSENCIAL: relacionamento com Actor
}

// ===============================================
// ESTRUTURAS PARA TRAILERS
// ===============================================

// Tabela para armazenar informações dos trailers de filmes
model MovieTrailer {
  id          String    @id @default(uuid()) @db.Uuid // ID interno do seu sistema
  movieId     String    @db.Uuid // ID do filme ao qual o trailer pertence
  tmdbId      String?   // ID do vídeo no TMDB (se for relevante para referência)
  key         String    // A chave do vídeo (ex: ID do YouTube)
  name        String?   // Nome/título do trailer (ex: "Official Trailer", "Teaser")
  site        String    // Plataforma de hospedagem (ex: "YouTube")
  type        String    // Tipo do vídeo (ex: "Trailer", "Teaser", "Clip")
  language    String?   // Idioma do trailer (ex: "en", "pt") - Este campo é CRUCIAL
  isMain      Boolean   @default(false) // Flag para indicar se é o trailer principal a ser exibido
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now())

  // Relação com a tabela Movie
  movie       Movie     @relation(fields: [movieId], references: [id])

  @@unique([movieId, key]) // Um trailer só pode ser associado uma vez a um filme
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@map("MovieTrailer") // Nome da tabela no banco
  @@index([tmdbId]) // ESSENCIAL: integração com TMDB
}

// ===============================================
// ESTRUTURAS PARA PREMIAÇÕES DETALHADAS
// ===============================================

model Award {
  id        String   @id @default(uuid()) @db.Uuid
  name      String   @unique // Ex: "Oscar", "Golden Globe Awards"
  category  String?  // Ex: "Cinema", "Television" (se o prêmio abrange mais de uma mídia)
  url       String?  // Link oficial do prêmio

  // Relações
  nominations MovieAwardNomination[]
  wins        MovieAwardWin[]
  personNominations PersonAwardNomination[]
  personWins        PersonAwardWin[]
  categories  AwardCategory[]

  @@map("Award")
  // Tabela pequena, sem índices desnecessários
}

model AwardCategory {
  id        String   @id @default(uuid()) @db.Uuid
  awardId   String   @db.Uuid
  name      String   // Ex: "Melhor Filme", "Melhor Ator", "Melhor Roteiro Original"

  // Relações
  award     Award    @relation(fields: [awardId], references: [id])
  movieNominations MovieAwardNomination[]
  movieWins        MovieAwardWin[]
  personNominations PersonAwardNomination[]
  personWins        PersonAwardWin[]

  @@unique([awardId, name]) // Uma categoria é única dentro de um prêmio
  @@map("AwardCategory")
  // Tabela pequena, sem índices desnecessários
}

// Para Indicações de Filmes
model MovieAwardNomination {
  id               String        @id @default(uuid()) @db.Uuid
  movieId          String        @db.Uuid
  awardId          String        @db.Uuid
  awardCategoryId  String        @db.Uuid
  year             Int           // Ano da cerimônia/indicação

  // Relações
  movie            Movie         @relation(fields: [movieId], references: [id])
  award            Award         @relation(fields: [awardId], references: [id])
  awardCategory    AwardCategory @relation(fields: [awardCategoryId], references: [id])

  @@unique([movieId, awardId, awardCategoryId, year]) // Um filme só pode ser indicado uma vez em uma categoria por ano
  @@map("MovieAwardNomination")
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([year]) // ESSENCIAL: consultas por ano
}

// Para Vitórias de Filmes
model MovieAwardWin {
  id               String        @id @default(uuid()) @db.Uuid
  movieId          String        @db.Uuid
  awardId          String        @db.Uuid
  awardCategoryId  String        @db.Uuid
  year             Int           // Ano da cerimônia/vitória

  // Relações
  movie            Movie         @relation(fields: [movieId], references: [id])
  award            Award         @relation(fields: [awardId], references: [id])
  awardCategory    AwardCategory @relation(fields: [awardCategoryId], references: [id])

  @@unique([movieId, awardId, awardCategoryId, year]) // Um filme só pode ganhar uma vez em uma categoria por ano
  @@map("MovieAwardWin")
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([year]) // ESSENCIAL: consultas por ano
}

// Para Indicações de Pessoas (Atores, Diretores, etc.)
model PersonAwardNomination {
  id               String        @id @default(uuid()) @db.Uuid
  personId         String        @db.Uuid // Pode ser actorId, directorId, etc.
  awardId          String        @db.Uuid
  awardCategoryId  String        @db.Uuid
  year             Int           // Ano da cerimônia/indicação
  forMovieId       String?       @db.Uuid // Opcional: para qual filme a pessoa foi indicada

  // Relações
  person           Actor         @relation(fields: [personId], references: [id])
  award            Award         @relation(fields: [awardId], references: [id])
  awardCategory    AwardCategory @relation(fields: [awardCategoryId], references: [id])
  forMovie         Movie?        @relation("PersonAwardForMovie", fields: [forMovieId], references: [id])

  @@unique([personId, awardId, awardCategoryId, year])
  @@map("PersonAwardNomination")
  @@index([personId]) // ESSENCIAL: relacionamento com Actor
  @@index([forMovieId]) // ESSENCIAL: relacionamento com Movie
  @@index([year]) // ESSENCIAL: consultas por ano
}

// Para Vitórias de Pessoas
model PersonAwardWin {
  id               String        @id @default(uuid()) @db.Uuid
  personId         String        @db.Uuid
  awardId          String        @db.Uuid
  awardCategoryId  String        @db.Uuid
  year             Int           // Ano da cerimônia/vitória
  forMovieId       String?       @db.Uuid // Opcional: para qual filme a pessoa ganhou

  // Relações
  person           Actor         @relation(fields: [personId], references: [id])
  award            Award         @relation(fields: [awardId], references: [id])
  awardCategory    AwardCategory @relation(fields: [awardCategoryId], references: [id])
  forMovie         Movie?        @relation("PersonAwardForMovieWin", fields: [forMovieId], references: [id])

  @@unique([personId, awardId, awardCategoryId, year])
  @@map("PersonAwardWin")
  @@index([personId]) // ESSENCIAL: relacionamento com Actor
  @@index([forMovieId]) // ESSENCIAL: relacionamento com Movie
  @@index([year]) // ESSENCIAL: consultas por ano
}

// Para críticas do filme
model Quote { 
  id               Int        @id @default(autoincrement())
  movieId          String        @db.Uuid
  text             String
  author           String?
  vehicle          String?
  url              String?        @db.VarChar(500) // URL do veículo que citou a crítica
  movie            Movie         @relation(fields: [movieId], references: [id])

  @@map("Quote")
  @@index([movieId]) // ESSENCIAL: relacionamento com Movie
  @@index([author]) // ESSENCIAL: busca por autor
}